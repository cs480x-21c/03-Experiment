<script src="https://d3js.org/d3.v4.min.js"></script>


<style>
</style>

<!-- <body>
  <h1> Experiment </h1>
  <div id="vis"></div>
</body>

<script>
  console.log(d3); // test if d3 is loaded

  // Set up grid dimensions
  var margin = {top: 20, right: 20, bottom: 20, left: 20}
  var width = 540 - margin.right - margin.left
  var height = 540 - margin.top - margin.bottom

  // Create SVG
  var svg = d3.select("#vis")
  .append('svg')
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

  function verticalBarChart () {
    // Dummy data (to be randomly generated on backend)
    dummyData = [ ['a', 10], ['b', 20], ['c', 25], ['d', 16], ['e', 37], ['f', 43] ] // assume: y axis ranges 1- 50
    dummySelectedData = ['a', 'd'] 

    // Create grid
    svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none")
    
    // x axis
    var x = d3.scaleBand()
    .domain(dummyData.map(function(d) {return d[0]}))
    .range([0, width])
    .padding(0.2)
    svg.append("g")
    .attr("transform", "translate(0, "+ height + ")")
    .call(d3.axisBottom(x).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")

    // y axis
    var y = d3.scaleLinear().domain([0, 50]).range([height, 0])
    svg.append("g")
    .call(d3.axisLeft(y).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")

    // Create bars
    svg.selectAll("bar")
    .data(dummyData)
    .enter()
    .append("g")
    .attr("id", function(d) { return d[0] })
    .append('rect')
    .style("fill", "none")
    .style("stroke", "black")
    .attr("x", function(d) { return x(d[0]) })
    .attr("y", function(d) { return y(d[1]) })
    .attr("width", x.bandwidth())
    .attr("height", function(d) { return height - y(d[1]) })

    // Add dots to selected bars 
    dummySelectedData.forEach(id => {
      var selectedBar = d3.select('#' + id)
      selectedBar.append("circle")
      .attr("cx", function(d) { return x(d[0]) + x.bandwidth()/2 })
      .attr("cy", width + margin.bottom/2)
      .attr("r", 5)
    })
  }

  function horizontalBarChart() {
    // Dummy data (to be randomly generated on backend)
    dummyData = [ ['a', 10], ['b', 20], ['c', 25], ['d', 16], ['e', 37], ['f', 43] ] // assume: y axis ranges 1- 50 
    dummySelectedData = ['a', 'd'] 

    // Create grid
    svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none")

    // x axis
    var x = d3.scaleLinear().domain([0, 50]).range([0, width])
    svg.append("g")
    .attr("transform", "translate(0, "+ height + ")")
    .call(d3.axisBottom(x).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")
    
    // y axis
    var y = d3.scaleBand()
    .domain(dummyData.map(function(d) {return d[0]}))
    .range([0, height])
    .padding(0.2)
    svg.append("g")
    .call(d3.axisLeft(y).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")

    // Create bars
    svg.selectAll("bar")
    .data(dummyData)
    .enter()
    .append("g")
    .attr("id", function(d) { return d[0] })
    .append("rect")
    .style("fill", "none")
    .style("stroke", "black")
    .attr("x", x(0))
    .attr("y", function(d) { return y(d[0]) })
    .attr("width", function(d) { return x(d[1]) })
    .attr("height", y.bandwidth())

    // Add dots to selected bars 
    dummySelectedData.forEach(id => {
      var selectedBar = d3.select('#' + id)
      selectedBar.append("circle")
      .attr("cx", -(margin.right/2))
      .attr("cy", function(d) { return y(d[0]) + y.bandwidth()/2 })
      .attr("r", 5)
    })
  }

  function angleChart() {
    // Dummy data (to be randomly generated on backend)
    dummyData = [ 
      {label: 'a', angle: randomAngles()}, 
      {label: 'b', angle: randomAngles()}, 
      {label: 'c', angle: randomAngles()}, 
      {label: 'd', angle: randomAngles()}, 
      {label: 'e', angle: randomAngles()},
      {label: 'f', angle: randomAngles()}, 
      // {label: 'g', angle: randomAngles()}, 
      // {label: 'h', angle: randomAngles()}, 
      // {label: 'i', angle: randomAngles()}, 
      // {label: 'j', angle: randomAngles()}  
    ] 

    // Static data to generate and position lines
    dummyLine = [ [250, 250], [250, 200]  ]
    staticPositions = [ [50, 150], [0, 0], [50, -100], [-150, -100], [-150, 50], [200, 200], [-100, -200], [150, -200], [200, 0], [-150, 200] ]

    // Create grid
    svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none")

    // x axis
    var x = d3.scaleLinear().domain([0, 50]).range([0, width])
    svg.append("g")
    .attr("transform", "translate(0, "+ height + ")")
    .call(d3.axisBottom(x).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")
    
    // y axis
    var y = d3.scaleBand()
    .domain(dummyData.map(function(d) {return d[0]}))
    .range([0, height])
    .padding(0.2)
    svg.append("g")
    .call(d3.axisLeft(y).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")

    counter = 0
    
    dummyData.forEach(data => {

      // Create G elt to contain line + text
      var g = svg.append("g")
      .attr("id", data.label)

      // Create line
      g.append("path")
      .datum(dummyLine)
      .attr("stroke", "black")
      .attr("stroke-width", 2)
      .attr("d", d3.line()
        .x(function(d) { return d[0] })
        .y(function(d) { return d[1] })
      )
      .attr("transform", function(d) {
        return "translate(" + staticPositions[counter][0] + " " + staticPositions[counter][1] + ") rotate(" + data.angle + " 250 250)" 
      })

      // Create label
      g.append("text")
      .data(data.label)
      .text(function (d) { return d })
      .attr("x", 260) 
      .attr("y", 260) 
      .attr("transform", function(d) {
        return "translate(" + staticPositions[counter][0] + " " + staticPositions[counter][1] + ")" 
      })

      counter++
    })
  }

  function volumeChart() {

  }

  // Generate random angles 0 - 360 degrees
  function randomAngles() {
    return Math.floor(Math.random() * (360 - 0 + 1))
  }

  // verticalBarChart()
  horizontalBarChart()
  // angleChart() -->



  <!DOCTYPE html>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://unpkg.com/d3-3d/build/d3-3d.min.js"></script>
  <body>
  <svg width="500" height="500"></svg>
  <!-- <svg id="vis"></svg> -->

  <script>

    // Set up grid dimensions
    var margin = {top: 20, right: 20, bottom: 20, left: 20}
    var width = 540 - margin.right - margin.left
    var height = 540 - margin.top - margin.bottom

    // Create SVG
    var svg = d3.select('svg')
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g')

    // Create grid
    svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none")

    // x axis
    var x = d3.scaleLinear().domain([0, 50]).range([0, width])
    svg.append("g")
    .attr("transform", "translate(0, "+ height + ")")
    .call(d3.axisBottom(x).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")
    
    // y axis
    var y = d3.scaleBand()
    .domain([0, 50])
    .range([0, height])
    .padding(0.2)
    svg.append("g")
    .call(d3.axisLeft(y).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")




     var svg = d3.select('svg').call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g')
      var origin = [200, 200], scale = 20, cubesData = [], alpha = 0, beta = 0, startAngle = Math.PI/6
      var cubesGroup = svg.append('g').attr('class', 'cubes')
      var mx, my, mouseX, mouseY
  
      var cubes3D = d3._3d()
        .shape('CUBE')
        .x(function(d){ return d.x })
        .y(function(d){ return d.y })
        .z(function(d){ return d.z })
        .rotateY( startAngle)
        .rotateX(-startAngle)
        .origin(origin)
        .scale(scale)
  
      function processData(data) {
  
        // Cubes
        var cubes = cubesGroup.selectAll('g.cube').data(data, function(d){ return d.id })
        var ce = cubes
          .enter()
          .append('g')
          .attr('class', 'cube')
          .attr('fill', "none") 
          .attr('stroke',"black") 
          .merge(cubes)
    
        // Faces
        var faces = cubes.merge(ce).selectAll('path.face').data(function(d){ return d.faces; }, function(d){ return d.face })
        faces.enter()
          .append('path')
          .attr('class', 'face')
          .merge(faces)
          .attr('d', cubes3D.draw)
      }
  
      function init() {
        cubesData = []

        var z = 0 // y pos
        var x = 10 // x pos
        var h = 2 // height
        var _cube = makeCube(h, x, z)
        _cube.id = 'cube_1'
        _cube.height = h
        cubesData.push(_cube)

        var z = 0 // y pos
        var x = 0 // x pos
        var h = 5 // height
        var _cube = makeCube(h, x, z)
        _cube.id = 'cube_2'
        _cube.height = h
        cubesData.push(_cube)

        processData(cubes3D(cubesData))
      }
  
      function dragStart() {
        mx = d3.event.x
        my = d3.event.y
      }
  
      function dragged() {
        mouseX = mouseX || 0
        mouseY = mouseY || 0
        beta   = (d3.event.x - mx + mouseX) * Math.PI / 230 
        alpha  = (d3.event.y - my + mouseY) * Math.PI / 230  * (-1)
        processData(cubes3D.rotateY(beta + startAngle).rotateX(alpha - startAngle)(cubesData), 0)
      }
  
      function dragEnd() {
        mouseX = d3.event.x - mx + mouseX
        mouseY = d3.event.y - my + mouseY
      }
  
      function makeCube(h, x, z) {
        return [
          {x: x - h/2, y: h, z: z + h/2}, // FRONT TOP LEFT
          {x: x - h/2, y: 0, z: z + h/2}, // FRONT BOTTOM LEFT
          {x: x + h/2, y: 0, z: z + h/2}, // FRONT BOTTOM RIGHT
          {x: x + h/2, y: h, z: z + h/2}, // FRONT TOP RIGHT
          {x: x - h/2, y: h, z: z - h/2}, // BACK  TOP LEFT
          {x: x - h/2, y: 0, z: z - h/2}, // BACK  BOTTOM LEFT
          {x: x + h/2, y: 0, z: z - h/2}, // BACK  BOTTOM RIGHT
          {x: x + h/2, y: h, z: z - h/2}, // BACK  TOP RIGHT
        ]
      }
  
      init()
  </script>
  </body>




















</script>
