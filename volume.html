<html>
  <head>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://unpkg.com/d3-3d/build/d3-3d.min.js"></script>
    <link rel="stylesheet" href="stylesheet.css">
  </head>
 
  <body>
    <svg id="vis"></svg>
    <p>This test is to see how the human brain distinguishes and understands the difference in volume between a small cube and a large cube.</p>
    <p>How many times can the small cube fit in the large cube?</p>
  </body>

  <script>
    // Set up grid dimensions
    var margin = {top: 20, right: 20, bottom: 20, left: 20}
    var width = 540 - margin.right - margin.left
    var height = 540 - margin.top - margin.bottom

    // Create SVG
    var svg = d3.select('svg')
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

    // Create grid
    svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "none")

    // x axis
    var x = d3.scaleLinear().domain([0, 50]).range([0, width])
    svg.append("g")
    .attr("transform", "translate(0, "+ height + ")")
    .call(d3.axisBottom(x).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")
    
    // y axis
    var y = d3.scaleBand()
    .domain([0, 50])
    .range([0, height])
    .padding(0.2)
    svg.append("g")
    .call(d3.axisLeft(y).tickFormat("").tickSize(0))
    .style("stroke-width", "1.5px")

    var svg = d3.select('svg').call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g')
    var origin = [200, 200], scale = 20, cubesData = [], alpha = 0, beta = 0, startAngle = Math.PI/6
    var cubesGroup = svg.append('g').attr('class', 'cubes')
    var mx, my, mouseX, mouseY
  
    // Create cube using d3 3D
    var cubes3D = d3._3d()
      .shape('CUBE')
      .x(function(d){ return d.x })
      .y(function(d){ return d.y })
      .z(function(d){ return d.z })
      .rotateY( startAngle)
      .rotateX(-startAngle)
      .origin(origin)
      .scale(scale)

    init()
  
    // Initialize cubes
    function init() {
      cubesData = []

      // Large cube
      var z = 0 // y pos
      var x = 10 // x pos
      var h = 2 // height
      var _cube = makeCube(h, x, z)
      _cube.id = 'cube_1'
      _cube.height = h
      cubesData.push(_cube)

      // Small cube
      var z = 0 // y pos
      var x = 0 // x pos
      var h = 5 // height
      var _cube = makeCube(h, x, z)
      _cube.id = 'cube_2'
      _cube.height = h
      cubesData.push(_cube)

      processData(cubes3D(cubesData))
    }

    // Attach cubes & faces to svg
    function processData(data) {

      var cubes = cubesGroup.selectAll('g.cube').data(data, function(d){ return d.id })
      var ce = cubes
        .enter()
        .append('g')
        .attr('class', 'cube')
        .attr('fill', "none") 
        .attr('stroke',"black") 
        .merge(cubes)
    
      var faces = cubes.merge(ce).selectAll('path.face').data(function(d){ return d.faces; }, function(d){ return d.face })
      faces.enter()
        .append('path')
        .attr('class', 'face')
        .merge(faces)
        .attr('d', cubes3D.draw)
    }
  
    function dragStart() {
      mx = d3.event.x
      my = d3.event.y
    }
  
    function dragged() {
      mouseX = mouseX || 0
      mouseY = mouseY || 0
      beta   = (d3.event.x - mx + mouseX) * Math.PI / 230 
      alpha  = (d3.event.y - my + mouseY) * Math.PI / 230  * (-1)
      processData(cubes3D.rotateY(beta + startAngle).rotateX(alpha - startAngle)(cubesData), 0)
    }
  
    function dragEnd() {
      mouseX = d3.event.x - mx + mouseX
      mouseY = d3.event.y - my + mouseY
    }
  
    // Construct cube
    function makeCube(h, x, z) {
      return [
        {x: x - h/2, y: h, z: z + h/2}, // FRONT TOP LEFT
        {x: x - h/2, y: 0, z: z + h/2}, // FRONT BOTTOM LEFT
        {x: x + h/2, y: 0, z: z + h/2}, // FRONT BOTTOM RIGHT
        {x: x + h/2, y: h, z: z + h/2}, // FRONT TOP RIGHT
        {x: x - h/2, y: h, z: z - h/2}, // BACK  TOP LEFT
        {x: x - h/2, y: 0, z: z - h/2}, // BACK  BOTTOM LEFT
        {x: x + h/2, y: 0, z: z - h/2}, // BACK  BOTTOM RIGHT
        {x: x + h/2, y: h, z: z - h/2}, // BACK  TOP RIGHT
      ]
    }
  
  </script>

 </html>